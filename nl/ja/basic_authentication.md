---

copyright:
  years: 2018, 2019
lastupdated: "2018-11-19"

keywords: security, basic authentication, protecting resources, tokens, scopemapping

subcollection:  mobilefoundation
---

{:shortdesc: .shortdesc}
{:new_window: target="_blank"}
{:tip: .tip}
{:pre: .pre}
{:codeblock: .codeblock}
{:screen: .screen}
{:note: .note}
{:important: .important}
{:deprecated: .deprecated}


# 認証およびセキュリティー
{: #basic_authentication}

MobileFirst セキュリティー・フレームワークは、[OAuth 2.0](http://oauth.net/) プロトコルに基づいています。 このプロトコルに従って、リソースは、そのリソースにアクセスするために必要な許可を定義する**スコープ**によって保護されます。 保護リソースにアクセスするために、クライアントは一致する**アクセス・トークン**を提供する必要があります。アクセス・トークンは、クライアントに付与される許可のスコープをカプセル化したものです。

OAuth プロトコルは、許可サーバーのロールと、リソースがホストされているリソース・サーバーのロールを分離します。

* 許可サーバーは、クライアント許可およびトークン生成を管理します。
* リソース・サーバーは、許可サーバーを使用して、クライアントから提供されたアクセス・トークンを検証し、要求されたリソースの保護スコープに一致しているか確認します。

セキュリティー・フレームワークは、OAuth プロトコルを実装する許可サーバーに基づいて構築され、クライアントがアクセス・トークンを取得するために対話する OAuth エンドポイントを公開します。 セキュリティー・フレームワークは、許可サーバーと基礎となる OAuth プロトコルの上にカスタム許可ロジックを実装するためのビルディング・ブロックを提供します。デフォルトでは、MobileFirst Server が**許可サーバー**としても機能します。 しかし、IBM WebSphere DataPower アプライアンスを許可サーバーとして機能するように構成し、MobileFirst Server と対話するように構成することもできます。

クライアント・アプリケーションは、その後、これらのトークンを使用して**リソース・サーバー**上のリソースにアクセスできます。リソース・サーバーには、MobileFirst Server 自体または外部サーバーを使用できます。 リソース・サーバーはトークンの妥当性をチェックし、要求されたリソースへのアクセスをクライアントに認可していいかを検査します。 リソース・サーバーと許可サーバーを分離することで、MobileFirst Server の外部で稼働するリソースに対してセキュリティーが適用されます。

アプリケーション開発者は、各保護リソースに必要なスコープを定義し、セキュリティー検査およびチャレンジ・ハンドラーを実装することで、リソースへのアクセスを保護します。 サーバー・サイドのセキュリティー・フレームワークとクライアント・サイド API は、OAuth メッセージ交換と許可サーバーとの対話を透過的に処理し、開発者が許可ロジックにのみ焦点を当てることができるようにします。

## 許可エンティティー
{: #acs_authorization_entitiesty}

### アクセス・トークン
{: #acs_access_tokens}

MobileFirst アクセス・トークンは、クライアントの許可アクセス権を記述したデジタル署名済みエンティティーです。 特定のスコープについてクライアントの認証要求が許可され、クライアントが認証されると、許可サーバーのトークン・エンドポイントは、要求されたアクセス・トークンを含む HTTP 応答をクライアントに送信します。

#### アクセス・トークンの構造

MobileFirst アクセス・トークンには、以下の情報が含まれます。

* **クライアント ID**: クライアントの固有 ID。
* **スコープ**: トークンが適用される有効範囲 (OAuth スコープを参照)。 このスコープには、必須アプリケーション・スコープは含まれません。
* **トークンの有効期限**: トークンが無効 (期限切れ) になる時間 (秒数)。

#### トークンの有効期限

付与されたアクセス・トークンは、有効期限時刻が経過するまで有効になります。 アクセス・トークンの有効期限時刻は、スコープ内のすべてのセキュリティー検査の有効期限時刻の中で最短の有効期限時刻に設定されます。 ただし、最短の有効期限時刻までの期間が、アプリケーションの最大トークン有効期限期間よりも長い場合、トークンの有効期限時刻は現在時刻に最大有効期限期間を加算したものに設定されます。 デフォルトのトークンの最大有効期間は 3,600 秒 (1 時間) ですが、``maxTokenExpiration`` プロパティーの値を設定することで、期間を構成できます。

**アクセス・トークンの最大有効期間の構成**
{: #acs_config-max-access-tokens}

以下のいずれかの選択肢の方法により、アプリケーションのアクセス・トークンの最大有効期間を構成します。

* MobileFirst Operations Console の使用
    1. **「 [ご使用のアプリケーション] 」**→**「セキュリティー」**タブを選択します。
    2. **「トークン構成」**セクションで、**「トークンの最大有効期間 (秒)」**フィールドの値を希望の値に設定し、**「保存」**をクリックします。 いつでもこの手順を繰り返してトークンの最大有効期間を変更することや、**「デフォルトに戻す」**を選択してデフォルト値に戻すことが可能です。

* アプリケーションの構成ファイルの編集

    1. CLI からプロジェクトのルート・フォルダーにナビゲートし、以下のコマンドを実行します。
      ```bash
      mfpdev app pull
      ```
    2. `[project-folder]\mobilefirst` フォルダーにある構成ファイルを開きます。
    3. `maxTokenExpiration` プロパティーを定義し、その値をアクセス・トークンの最大有効期間 (秒数) に設定して、ファイルを編集します。
        ```java
        {
            ...
            "maxTokenExpiration": 7200
        }
        ```
        {: codeblock}
    4. コマンド ``mfpdev app push`` を実行することで、更新済み構成 JSON ファイルをデプロイします。

**アクセス・トークン応答構造**
{: #acs_access-tokens-structure}

アクセス・トークン要求に対する成功時の HTTP 応答には、アクセス・トークンおよび追加データが入っている JSON オブジェクトが含まれます。 以下に、許可サーバーからの有効なトークンの応答の例を示します。

```json
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache
{
    "token_type": "Bearer",
    "expires_in": 3600,
    "access_token": "yI6ICJodHRwOi8vc2VydmVyLmV4YW1",
    "scope": "scopeElement1 scopeElement2"
}
```
{: codeblock}

トークン応答 JSON オブジェクトには、以下のプロパティー・オブジェクトが含まれます。

* **token_type**: トークン・タイプは常に "*Bearer*" ([OAuth 2.0 Bearer Token Usage 仕様](https://tools.ietf.org/html/rfc6750)に準拠)。
* **expires_in**: アクセス・トークンの有効期限を表す時間 (秒数)。
* **access_token**: 生成されたアクセス・トークン (実際のアクセス・トークンは、例で示されているものよりも長くなります)。
* **scope**: 要求されたスコープ。

**expires_in** および **scope** の情報は、トークン自体 (**access_token**) にも含まれています。

>**注**: 有効なアクセス・トークン応答の構造を把握しておく必要があるのは、ユーザー自身が下位の `WLAuthorizationManager` クラスを使用してクライアントと許可サーバーおよびリソース・サーバーとの間の OAuth 対話を管理する場合、または機密クライアントを使用する場合です。 保護リソースにアクセスするための OAuth フローをカプセル化する、上位 `WLResourceRequest` クラスを使用している場合は、セキュリティー・フレームワークが、ユーザーに代わって、アクセス・トークン応答の処理を行います。 [クライアント・セキュリティー API](http://www.ibm.com/support/knowledgecenter/en/SSHS8R_8.0.0/com.ibm.worklight.dev.doc/dev/c_oauth_client_apis.html?view=kc#c_oauth_client_apis) および[機密クライアント](https://mobilefirstplatform.ibmcloud.com/tutorials/en/foundation/8.0/authentication-and-security/confidential-clients/)を参照してください。

### リフレッシュ・トークン
{: #acs_refresh_tokens}

リフレッシュ・トークンは特殊なタイプのトークンであり、アクセス・トークンの有効期限が切れたときに新しいアクセス・トークンを取得するために使用できます。 新しいアクセス・トークンを要求するには、有効なリフレッシュ・トークンを提示します。 リフレッシュ・トークンは存続期間が長いトークンであり、アクセス・トークンと比較してより長い期間有効です。

リフレッシュ・トークンは、ユーザーが永続的に認証済みのままになることができるため、アプリケーションでは注意して使用する必要があります。 アプリケーション・プロバイダーがユーザーを定期的に認証しないソーシャル・メディア・アプリケーション、e-commerce アプリケーション、製品カタログ・ブラウズ・アプリケーションなどのユーティリティー・アプリケーションでは、リフレッシュ・トークンを使用できます。 頻繁なユーザー認証を要求するアプリケーションでは、リフレッシュ・トークンの使用を避ける必要があります。
MobileFirst リフレッシュ・トークン

MobileFirst リフレッシュ・トークンは、クライアントの許可アクセス権を記述したアクセス・トークンのような、デジタル署名されたエンティティーです。 リフレッシュ・トークンは、同じスコープの新しいアクセス・トークンを取得するために使用できます。 特定のスコープについてクライアントの認証要求が許可され、クライアントが認証されると、許可サーバーのトークン・エンドポイントは、要求されたアクセス・トークンとリフレッシュ・トークンを含む HTTP 応答をクライアントに送信します。 アクセス・トークンの有効期限が切れると、クライアントは、新しいアクセス・トークンとリフレッシュ・トークンのセットを取得するために、許可サーバーのトークン・エンドポイントにリフレッシュ・トークンを送信します。

#### リフレッシュ・トークンの構造

MobileFirst アクセス・トークンと同様、MobileFirst リフレッシュ・トークンには以下の情報が含まれています。

* **クライアント ID**: クライアントの固有 ID。
* **スコープ**: トークンが適用される有効範囲 (OAuth スコープを参照)。 このスコープには、必須アプリケーション・スコープは含まれません。
* **トークンの有効期限**: トークンが無効 (期限切れ) になる時間 (秒数)。

**トークンの有効期限**

リフレッシュ・トークンのトークン有効期間は、一般的なアクセス・トークンの有効期間よりも長くなっています。 付与されたリフレッシュ・トークンは、有効期限時刻が経過するまで有効になります。 この有効期間内に、クライアントはリフレッシュ・トークンを使用して、新しいアクセス・トークンとリフレッシュ・トークンのセットを取得できます。 リフレッシュ・トークンには、30 日の固定の有効期間があります。 クライアントが新しいアクセス・トークンとリフレッシュ・トークンのセットを正常に受信するたびに、リフレッシュ・トークンの有効期限がリセットされるため、クライアントではトークンの有効期限が切れることはありません。 アクセス・トークンの有効期限ルールは、**アクセス・トークン**のセクションで説明されているものと同じです。

**リフレッシュ・トークン機能の有効化**
{: #acs_enable-refresh-token}

リフレッシュ・トークン機能は、クライアント・サイドとサーバー・サイドでそれぞれ以下のプロパティーを使用して有効にできます。

**クライアント・サイド・プロパティー (Android)**
*ファイル名*: mfpclient.properties
*プロパティー名*: wlEnableRefreshToken
*プロパティー値*: true
例:
*wlEnableRefreshToken*=true

**クライアント・サイド・プロパティー (iOS)**
*ファイル名*: mfpclient.plist
*プロパティー名*: wlEnableRefreshToken
*プロパティー値*: true
例:
*wlEnableRefreshToken*=true

**サーバー・サイド・プロパティー**
*ファイル名*: server.xml
*プロパティー名*: mfp.security.refreshtoken.enabled.apps
*プロパティー値*: アプリケーションのバンドル ID は「;」で区切ります

例:

```xml
<jndiEntry jndiName="mfp/mfp.security.refreshtoken.enabled.apps" value='"com.sample.android.myapp1;com.sample.android.myapp2"'/>
```
{: codeblock}
プラットフォームに応じて異なるバンドル ID を使用してください。

**リフレッシュ・トークン応答構造**

以下に、許可サーバーからの有効なリフレッシュ・トークン応答の例を示します。

```json
    HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache
{
        "token_type": "Bearer",
            "expires_in": 3600,
            "access_token": "yI6ICJodHRwOi8vc2VydmVyLmV4YW1",
            "scope": "scopeElement1 scopeElement2",
            "refresh_token": "yI7ICasdsdJodHRwOi8vc2Vashnneh "
        }
```        
{: codeblock}

リフレッシュ・トークン応答には、アクセス・トークン応答構造のパートで説明した他のプロパティー・オブジェクトとは別に追加のプロパティー・オブジェクト `refresh_token` があります。

>**注**: リフレッシュ・トークンの存続期間は、アクセス・トークンと比較して長くなります。 そのため、リフレッシュ・トークン機能は注意して使用する必要があります。 定期的なユーザー認証が必要ないアプリケーションが、リフレッシュ・トークン機能を使用する場合に理想的な候補となります。

>MobileFirst は、CD update 3 から iOS でリフレッシュ・トークンをサポートしています。

#### セキュリティー検査
{: #acs_securitychecks}

セキュリティー検査は、サーバー・サイドのアプリケーション・リソースを保護するためのセキュリティー・ロジックを実装するサーバー・サイド・エンティティーです。 セキュリティー検査の簡単な例として、ユーザーの資格情報を受け取り、ユーザー・レジストリーに照らして資格情報を検査する、ユーザー・ログイン・セキュリティー検査があります。 別の例として、事前定義されている MobileFirst アプリケーション認証性セキュリティー検査があります。これは、モバイル・アプリケーションの認証性を検査することで、アプリケーションのリソースへの不正なアクセスから保護します。 同じセキュリティー検査を使用して、複数のリソースを保護することもできます。

セキュリティー検査は通常、クライアントが検査に合格するために特定の方法で応答する必要がある、セキュリティー・チャレンジを発行します。 このハンドシェークは、OAuth アクセス・トークン獲得フローの一部として発生します。 クライアントは**チャレンジ・ハンドラー**を使用して、セキュリティー検査のチャレンジを処理します。

**組み込みセキュリティー検査**

以下の事前定義セキュリティー検査を使用できます。

* アプリケーション認証性
* LTPA ベースのシングル・サインオン (SSO)
* ダイレクト・アップデート

#### チャレンジ・ハンドラー・エンティティー
{: #challengehandler_entity}

クライアントは、保護リソースにアクセスしようとするとき、チャレンジを提示されることがあります。 チャレンジは、クライアントがそのリソースへのアクセスを許可されていることを検査するためにサーバーが出す質問、セキュリティー・テスト、またはプロンプトです。 一般的に、このチャレンジは、ユーザー名とパスワードなどの資格情報を要求することです。

チャレンジ・ハンドラーは、クライアント・サイド・セキュリティー・ロジックおよびそれに関連したユーザーとの対話を実装する、クライアント・サイド・エンティティーです。

>**重要**: チャレンジを受け取ると、それを無視することはできません。 応答するか、あるいはキャンセルしなければなりません。 チャレンジを無視すると、予期しない動作が発生するおそれがあります。

### スコープ
{: #scopes}

アダプターなどのリソースにスコープを割り当てることにより、そのリソースを無許可アクセスから保護できます。

スコープは、スペースで区切った 1 つ以上のスコープ・エレメントからなるストリング (「scopeElement1 scopeElement2 …」) として定義することも、ヌルとして定義してデフォルトのスコープ (RegisteredClient) を適用することもできます。 MobileFirst セキュリティー・フレームワークでは、リソースにスコープが割り当てられていない場合でも、そのリソースのリソース保護を無効にしない限り、あらゆるアダプター・リソースにアクセス・トークンが必要です。

#### スコープ・エレメント
{: #scopeelements}

スコープ・エレメントには、以下のいずれかを指定できます。

* セキュリティー検査の名前。
* そのリソースで必要とされるセキュリティーのレベルを定義した任意のキーワード (`access-restricted`、`deletePrivilege` など)。このキーワードが後でセキュリティー検査にマップされます。

#### スコープ・マッピング
{: #scopemapping}

デフォルトで、**スコープ**内に記述する**スコープ・エレメント**は、同じ名前を持つ**セキュリティー検査**にマップされます。 例えば、`PinCodeAttempts` というセキュリティー検査を作成した場合、同じ名前のスコープ・エレメントをスコープ内に使用できます。

スコープ・マッピングは、スコープ・エレメントからセキュリティー検査へのマッピングを可能にします。クライアントがスコープ・エレメントを要求すると、この構成によって、適用する必要のあるセキュリティー検査が定義されます。例えば、スコープ・エレメント `access-restricted` を `PinCodeAttempts` セキュリティー検査にマップできます。

どのアプリケーションがリソースにアクセスしようとしているかに応じてリソースを保護する方法を変える必要がある場合、スコープ・マッピングが便利です。 同じスコープをゼロ個以上のセキュリティー検査のリストにマップすることもできます。

例: scope = `access-restricted deletePrivilege`

* アプリケーション A
    * `access-restricted` は `PinCodeAttempts` にマップされます。
    * `deletePrivilege` は空ストリングにマップされます。
* アプリケーション B
    * `access-restricted` は `PinCodeAttempts` にマップされます。
    * `deletePrivilege` は `UserLogin` にマップされます。

>スコープ・エレメントを空ストリングにマップするには、**「新しいスコープ・エレメント・マッピングの追加」**ポップアップ・メニューでセキュリティー検査を何も選択しないでください。

![スコープ・マッピング](/images/scope_mapping.png)

必要な構成を指定してアプリケーションの構成 JSON ファイルを手動で編集し、変更を MobileFirst Server にプッシュして戻すこともできます。

1. **コマンド・ライン・ウィンドウ**で、プロジェクトのルート・フォルダーにナビゲートし、`mfpdev app pull` を実行します。
2. `[project-folder]\mobilefirst` フォルダーにある構成ファイルを開きます。
3. ファイルを編集して、`scopeElementMapping` プロパティーを定義します。 このプロパティーには、データ・ペアを定義します。各ペアは、選択したスコープ・エレメントの名前と、そのエレメントのマップ先となるゼロ個以上のセキュリティー検査をスペースで区切ったストリングとで構成されます。 例えば、次のようにします。

```java
     "scopeElementMapping": {
         "UserAuth": "UserAuthentication",
        "SSOUserValidation": "LtpaBasedSSO CredentialsValidation"
    }
```
4. 以下のコマンドを実行することで、更新済み構成 JSON ファイルをデプロイします。
  ```bash
  mfpdev app push
  ```

更新済み構成をリモート・サーバーにプッシュすることもできます。 「MobileFirst CLI を使用した MobileFirst 成果物の管理」チュートリアルを参照してください。
{: note}

### リソースの保護
{: #protecting-resources}

OAuth モデルでは、保護リソースは、アクセス・トークンを必要とするリソースです。 MobileFirst セキュリティー・フレームワークを使用して、MobileFirst Server のインスタンス上にホストされたリソースと外部サーバー上のリソースの両方を保護できます。 リソースを保護するには、リソースのアクセス・トークンを取得するために必要な許可を定義するスコープをリソースに割り当てます。

リソースはいろいろな方法で保護できます。

#### 必須アプリケーション・スコープ
{: #mandatoryappscope}

アプリケーション・レベルでは、アプリケーションによって使用されるすべてのリソースに適用されるスコープを定義できます。 セキュリティー・フレームワークは、要求されたリソース・スコープのセキュリティー検査に加えて、これらの検査 (存在する場合) を実行します。

>**注**:
>* 必須アプリケーション・スコープは、無保護リソースにアクセスする場合は適用されません。
>* リソース・スコープに対して許可されたアクセス・トークンに、必須アプリケーション・スコープは含まれません。

MobileFirst Operations Console で、ナビゲーション・サイドバーの**「アプリケーション」**セクションからアプリケーションを選択した後、**「セキュリティー」**タブを選択します。 **「必須アプリケーション・スコープ」**の下で、**「スコープに追加」**を選択します。

![必須のアプリケーション・スコープ](/images/mandatory-application-scope.png)

必要な構成を指定してアプリケーションの構成 JSON ファイルを手動で編集し、変更を MobileFirst Server にプッシュして戻すこともできます。

1. **コマンド・ライン・ウィンドウ**で、プロジェクトのルート・フォルダーにナビゲートし、`mfpdev app pull` を実行します。
2. **project-folder\mobilefirst** フォルダーにある構成ファイルを開きます。
3. `mandatoryScope` プロパティーを定義し、選択したスコープ・エレメントのスペース区切りリストが入ったスコープ・ストリングをプロパティー値に設定することで、ファイルを編集します。 例:

    ```java
        "mandatoryScope": "appAuthenticity PincodeValidation"
    ```
4. コマンド mfpdev app push を実行することで、更新済み構成 JSON ファイルをデプロイします。

>更新済み構成をリモート・サーバーにプッシュすることもできます。

#### アダプター・リソースの保護
{: #protectadapterres}

アダプターでは、Java メソッドまたは JavaScript リソース・プロシージャーに対して、あるいは Java リソース・クラス全体に対して保護スコープを指定できます。 スコープは、スペースで区切った 1 つ以上のスコープ・エレメントからなるストリング (「scopeElement1 scopeElement2 …」) として定義することも、ヌルとして定義してデフォルトのスコープを適用することもできます。 アダプター・リソースを保護する方法について詳しくは、[アダプターの保護](/docs/services/mobilefoundation?topic=mobilefoundation-protecting_adapters#protecting_adapters)を参照してください。

### リソース保護の無効化
{: #disablingresprotection}

特定の Java アダプター・リソースまたは JavaScript アダプター・リソースに対して、あるいは Java クラス全体に対してデフォルトの MobileFirst リソース保護を無効にすることができます。それは、以下の Java セクションと JavaScript セクションで概説されています。 リソース保護が無効になっている場合、MobileFirst セキュリティー・フレームワークでは、リソースにアクセスするためにトークンは必要ありません。

#### Java リソース OAuth 保護の無効化
{: #disablejavaresoauthprotection}

Java リソース・メソッドまたはクラスの OAuth 保護を完全に無効にするには、以下のように、`@OAuthSecurity` アノテーションをこのリソースまたはクラスの宣言に追加し、`enabled` エレメントの値を `false` に設定します。

```
@OAuthSecurity(enabled = false)
```

アノテーションの `enabled` エレメントのデフォルト値は `true` です。 `enabled` エレメントが `false` に設定されている場合、`scope` エレメントは無視され、リソースまたはリソース・クラスは保護されません。

>**注**: 無保護クラスのメソッドにスコープを割り当てた場合、リソースのアノテーションの `enabled` エレメントを `false` に設定しない限り、クラスのアノテーションに関係なくそのメソッドは保護されます。

**例**

以下のコードは、`helloUser` メソッドのリソース保護を無効にします。

```java
    @GET
    @Path("/{username}")
    @OAuthSecurity(enabled = "false")
    public String helloUser(@PathParam("username") String name){
        ...
    }
```

以下のコードは、`MyUnprotectedResources` クラスのリソース保護を無効にします。

```java
    @Path("/users")
    @OAuthSecurity(enabled = "false")
    public class MyUnprotectedResources {
        ...
    }
```

#### JavaScript リソース OAuth 保護の無効化
{: #disablejavascriptresoauthprotection}

JavaScript アダプター・リソース (プロシージャー) の OAuth 保護を完全に無効にするには、**adapter.xml** ファイルで、<procedure> エレメントの `secured` 属性を `false` に設定します。

```javascript
<procedure name="procedureName" secured="false">
```

`secured` 属性が `false` に設定されている場合、`scope` 属性は無視され、リソースは保護されません。

**例**

以下のコードは、`userName` プロシージャーのリソース保護を無効にします。

```javascript
<procedure name="userName" secured="false">
```

### 無保護リソースの定義
{: #defunprotectedresources}

無保護リソースは、アクセス・トークンを必要としないリソースです。 MobileFirst セキュリティー・フレームワークは、無保護リソースへのアクセスを管理せず、また該当するリソースにアクセスするクライアントの ID を検証および検査しません。 そのため、無保護リソースでは、ダイレクト・アップデート、デバイス・アクセスのブロック、リモート側でのアプリケーションの無効化などの機能はサポートされません。

### 外部リソースの保護
{: #protecextresources}

外部リソースを保護するには、アクセス・トークン検証モジュールとともにリソース・フィルターを外部リソース・サーバーに追加します。 トークン検証モジュールは、セキュリティー・フレームワークの許可サーバーのイントロスペクション・エンドポイントを使用して、リソースに対するアクセス権限が OAuth クライアントに付与される前に、MobileFirst アクセス・トークンを検証します。MobileFirst ランタイム用の MobileFirst REST API を使用して、任意の外部サーバー用のアクセス・トークン検証モジュールを独自に作成できます。 外部 Java リソースを保護するために提供されているいずれかの MobileFirst 拡張機能を使用します。
